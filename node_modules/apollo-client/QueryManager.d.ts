import { NetworkInterface } from './networkInterface';
import { ApolloStore, Store } from './store';
import { QueryStoreValue } from './queries/store';
import { QueryTransformer } from './queries/queryTransform';
import { GraphQLResult, Document, FragmentDefinition } from 'graphql';
import { MutationBehavior } from './data/mutationResults';
import { Observable, Observer, Subscription } from './util/Observable';
export declare class ObservableQuery extends Observable<GraphQLResult> {
    subscribe(observer: Observer<GraphQLResult>): QuerySubscription;
    result(): Promise<GraphQLResult>;
}
export interface QuerySubscription extends Subscription {
    refetch(variables?: any): Promise<GraphQLResult>;
    stopPolling(): void;
    startPolling(pollInterval: number): void;
}
export interface WatchQueryOptions {
    query: Document;
    variables?: {
        [key: string]: any;
    };
    forceFetch?: boolean;
    returnPartialData?: boolean;
    pollInterval?: number;
    fragments?: FragmentDefinition[];
}
export declare type QueryListener = (queryStoreValue: QueryStoreValue) => void;
export declare class QueryManager {
    private networkInterface;
    private store;
    private reduxRootKey;
    private pollingTimers;
    private queryTransformer;
    private queryListeners;
    private idCounter;
    private scheduler;
    private batcher;
    private batcherPollInterval;
    private fetchQueryPromises;
    private observableQueries;
    constructor({networkInterface, store, reduxRootKey, queryTransformer, shouldBatch}: {
        networkInterface: NetworkInterface;
        store: ApolloStore;
        reduxRootKey: string;
        queryTransformer?: QueryTransformer;
        shouldBatch?: Boolean;
    });
    broadcastNewStore(store: any): void;
    mutate({mutation, variables, resultBehaviors, fragments}: {
        mutation: Document;
        variables?: Object;
        resultBehaviors?: MutationBehavior[];
        fragments?: FragmentDefinition[];
    }): Promise<GraphQLResult>;
    queryListenerForObserver(options: WatchQueryOptions, observer: Observer<GraphQLResult>): QueryListener;
    watchQuery(options: WatchQueryOptions, shouldSubscribe?: boolean): ObservableQuery;
    query(options: WatchQueryOptions): Promise<GraphQLResult>;
    fetchQuery(queryId: string, options: WatchQueryOptions): Promise<GraphQLResult>;
    generateQueryId(): string;
    stopQueryInStore(queryId: string): void;
    getApolloState(): Store;
    addQueryListener(queryId: string, listener: QueryListener): void;
    removeQueryListener(queryId: string): void;
    addFetchQueryPromise(requestId: number, promise: Promise<GraphQLResult>, resolve: (result: GraphQLResult) => void, reject: (error: Error) => void): void;
    removeFetchQueryPromise(requestId: number): void;
    addObservableQuery(queryId: string, observableQuery: ObservableQuery): void;
    addQuerySubscription(queryId: string, querySubscription: QuerySubscription): void;
    removeObservableQuery(queryId: string): void;
    resetStore(): void;
    private fetchQueryOverInterface(queryId, options, network);
    private startQuery(queryId, options, listener);
    private stopQuery(queryId);
    private broadcastQueries();
    private generateRequestId();
}
